Redis



[redis tutorial]


- key-value store
[Command]

<SET>
- 'SET' command로 key, value를 저장할 수 있다. 
ex) SET keyname "value"

<GET>


<DEL>
- 주어진 key에 대한 value를 지운다.
- 성공하면 return 1
- 실패하면 return 0


<INCR>
- 해당 키의 value를 하나 증가시킨다. 
- atoic operation이기에, 원자성 보존!!!!

<decr>
- 키에 저장된 값이 숫자일때, 1 감소시킨다. 
- 
<EXPIRE, TTL>
- key가 특정 시간동안만 존재하도록 할 수 있다. 
- key를 정의한 후 ,
ex) expire key 살아있을시간(초)
를 하면 해당 시간동안만 살아있게 된다.
ex) ttl key 
-> 해당 key의 남은 수명을 알려준다. 
- return -2 : 해당 key는 더이상 존재하지 않는다.
- return -1 : 절대 사라지지 않는 key이다. 


[data structure]
1) list
- series of ordered values(순서있음!)
- 가능한 command : rpush, lpush, llen, lrange, lpop, rpop 
- list의 element들은 type이 같아야 한다. 



<rpush>
- list의 마지막에 데이터를 넣는다. 


<lpush>
- list의 시작부분에 데이터를 넣는다. 

<lrange>
- list에 지정한 범위의 데이터를 반환한다. 
- 여기에서 -1은 끝까지를 의미한다. 
ex) lrange listname 시작위치 끝위치 

<llen>
- return current length of the list 

<lpop>
- remove the first element from the list and returns it 

<rpop>
- remote the last element from the list and returns it 


2) set
- list와 유사하지만, 데이터간의 순서가 없다.
- command : sadd, srem, sismember, smembers, sunion

<sadd>
- 해당 value를 set에 넣는다.
ex) sadd interns "lee"

<srem>
- 해당 value를 set에서 제거한다. 

<sismember>
- 해당 value가 set에 있는지 확인한다.
- return 1 : 존재 
- return 0 : 없음 

<smembers>
- set에 있는 모든 member들을 반환한다.

<sunion>
- 여러개의 set들을 합친다. 



3) sorted sets
- value에 'associated score'가 있다.
- 이 score를 기준으로 정렬이된다. 


4) hashes
- string field와 string value를 매핑한다. 
- object를 표현하기에 제일 좋다 
- numeric value는 string처럼 취급된다.
- numeric value의 증가는 <hincrby> command를 사용한다.
ex



[주기적인 통계 정보 조회]
- 메모리 상태, 저장된 키의 개수와 같은 서버의 통계 정보를 주기적으로 확인해야 한다면, 별도의 프로그램을 개발하기 보다는 
간단한 리눅스 셸명령과 크론탭을 사용하는 편이 낫다. 
- redis-cli info cpu : 메모리 상태 
- redis-cli info keyspace : 저장된 키의 개수 
- redis-cli info stats : 서버의 통계정보 


-------------------------------이것이 레디스다





Chapter3. NoSQL


3.1 정의 
- 대용량 웹 서비스를 위하여 만들어진 데이터 저장소
- 관계형 데이터 모델을 지양하며 대량의 분산된 데이터를 저장하고 조회하는데 특화된 저장소 
- 스키마 없이 사용 가능하거나, 느슨한 스키마를 제공하는 저장소 

'빅데이터를 처리하기 위한 분산 데이터 저장소의 통칭'



3.3 CAP 정리

- CAP 정리란, 분산 컴퓨터 시스템을 설명하는데 사용되는 이론이다.
- Consistency, availability, partition tolerance를 모두 동시에 지원하는 시스템은 없다.
- 웹서버와 db서버가 다른 하드웨어에 설치되는것이 분산 컴퓨팅이라고 한다.
- 이럴때, nosql은 일관성, 가용성, 분할 허용성 중 두 가지를 지원하고, 나머지 한 속성은 특정 조건에서만 만족한다. 가 cap정리의 핵심!

- 노드들의 집합 = 클러스터 
- 분산시스템은 하나 이상의 다중 클러스터로 구성될 수 있다. 



3.3.1 Consistency
- 동시성, 또는 동일성
- '다중 클라이언트에서 같은 시간에 조회하는 데이터는 항상 동일한 데이터 임을 보증'
- nosql에서는 빠른 분산 처리를 위하여 일관성을 희생하기도 한다. 그래서 시간이 지남에 따라 수정된 내용이 다른 노드로 전파되어 반영된다. 

- 각 nosql은 분산 노드 간의 데이터 동기화를 위해서 2가지 방법을 사용한다.
1) 동기식 방법 
 - 데이터의 저장 결과를 클라이언트에게 응답하기 전에, 모든 노드에 데이터를 저장.
 - 느린 응답시간을 보이지만, 강한 데이터의 정합성을 보장 
 
2) 비동기식 방법 
 - 임시파일이나, 메모리에 기록 후 클라이언트에게 먼저 응답
 - 특정 이벤트, 프로세스를 사용하여 노드로 데이터를 동기화 시킨다.
 

- 분산시스템에서 일관성을 유지하기 위해서는 latency(응답시간)의 희생이 따른다.
- 많은 nosql들이 읽기와 쓰기의 성능 향상을 위해 데이터를 메모리에 임시로 기록한 다음, 클라이언트에 응답하고 
백 그라운드 스레드로 해당 데이터를 디스크에 기록한다.
-> 하지만 하드웨어 장애 발생시에 데이터 유실이 발생할 수 있는데, 이는 커밋로그로 극복.


3.3.2 Availability
- '모든 클라이언트의 읽기와 쓰기 요청에 디하여 항상 응답이 가능해야 함을 보증'
- 클러스터내에서 몇 개의 노드가 죽어도 정상적인 서비스가 가능해야함.
- High Availability(고가용성)과 유사한 개념 
sol) 데이터복제 
 - 동일한 데이터를 다중 노드에 중복 저장하여, 일부 노드가 고장나도 데이터가 유실되지 않도록 함. 
 - 데이터 복제에는 <마스터-슬레이브> , <피어-투-피어> 방법이 있다. 
 <마스터-슬레이브>:동일한 데이터를 가지는 저장소를 하나 더 생성하는 방법.
 <peer2peer>:데이터 단위로 중복 저장하는 방법. 
 
[SPOF: Single Point of Failure]
- 단일 고장점 
- 시스템을 구성하는 개별 요소 중에서 하나의 요소가 망가졌을때 시스템 전체를 멈추게 만드는 요소 
- 단일 고장점을 가지면 availability를 지원할 수 없다.
- 


3.3.3 네트워크 분할 허용성 (Partition tolerance)
- 지역적으로 분할된 네트워크 환경에서 동작하는 시스템에서 두 지역 간의 네트워크가 단절되거나 
네트워크 데이터의 유실이 일어나더라도 각 지역 내의 시스템은 정상적으로 동작해야함.
- 




3.4 nosql 종류
- 키-값, 문서, 컬럼, 그래프 모델로 분류


3.4.1 키-값 모델 
- 사용자의 프로필 정보, 웹 서버의 클러스터를 위한 세션 정보, 장바구니 정보 등에 활용. 
- 단일 연산에 의하여 완료/처리될 수 있는 것들.
- 복잡한 다중 연산에 어울리지 않음. 
- 키-값 모델은 단일키 처리만을 지원한다. 
- transaction 처리가 불가능하여 데이터 정합성을 보장할 수 없다. 



3.4.2 문서 모델 

-







3.5 언제 nosql을 사용해야 하는가?
- 대량의 단순 정보를 빠르게 저장하고 조회할 때. 
- 스키마가 고정되지 않은 데이터를 저장하고 조회할때.


- nosql 선택시 고려사항 
 1) 일관성 모델 
  - 
 2) 데이터 모델 
 
 3) 읽기 쓰기 성능 

 4) 단일 고장점 
 
 5) 원자성 지원 
 
 6) 하드웨어 구성 
  - 해당 nosql이 가지는 시스템 아키텍처를 확인해야함.
 7) 무중단 시스템 
  - 







  
  
  
Chapter4. 레디스 시작 


4.1 레디스와 데이터 구조 
- 총 5개의 데이터형이 있다. 
- 레디스는 거대한 key-value 저장소이다. (map 구조)
- 




4.2 레디스 데이터 구조와 명령어 

- <데이터 처리 명령>, <키 관리 명령><서버 관리 명령> 크게 세 가지가 있다.

4.2.1 문자열 데이터 
- key 하나에 문자열 1개 저장.
- 문자열은 최대 512MB
- 문자열 데이터는 <인코딩된 문자열> + <부가정보> = 레디스 객체형으로 변환하여 저장한다.


<MSET>
- KEY-VALUE쌍을 여러개를 입력한다.


<MGET>
- 주어진 여러개의 KEY에 대해서 VALUE를 return


<msetnx>
- 여러 key-value 쌍을 입력.
- 이미 존재하는 값이 있다면, 모든 쌍을 저장하지 않는다.



<getset>
- 지금 값을 반환하고, 새로운 값을 저장한다. 
- 만약 존재하지 않는 키였으면, 저장을 수행하고 nil을 반환. 



[숫자의 증가와 감소]

<incrby>
- 인자로 입력된 값 만큼 증가한다.
<decrby>
- 인자로 입력된 값 만큼 감소한다.

[비트연산]
- 비트연산을 통해 저장되는 문자열 데이터를 비트 단위로 처리할 수 있다.
- 비트연산을 'switch'로 생각해라!!!! 

ex) 로그인 처리.

key: 160723 => 160723에 로그인 여부를 체크하는 키값. 
사용자id-> 번호로 바꿈.
해당 번호를 offset으로 하여 switch on 시킨다.

<getbit>

<setbit>
- 주어진 키에 대해 값 처리.
- 입력된 offset 위치에 저장된 bit 값을 변경한다. 


<strlen>
- 키에 저장된 value의 길이를 반환.
- 키가 존재하지 않으면 0 

<bitcount>
- 해당 key에 1로 set된 bit의 수를  반환한다.
- range index는 bit단위가 아니라 byte단위로 범위가 지정된다! 



4.2.2 해시 데이터 

- 해시데이터는 map 구조 
- 필드-값 구조이다
- 2^32-1개의 필드와 값을 저장할 수 있다.
- 해시 관련 모든 명령어는 상수 시간 복잡도이다!
- 키 하나가 여러개의 필드-값 쌍으로 이루어진다. 

[그룹 데이터 저장]
<hmset>
- 주어진 필드와 값의 쌍들을 저장한다.
ex) hmset "key" "field-name" "field-value" "field-name" "field-value" . . . 




<hsetnx> 
- 주어진 필드가 존재하지 않을 떄 저장한다.

<hmget>

<hlen>
- 주어진 키에 저장된 필드의 개수를 조회한다.
 
 
<hdel>
- 주어진 키에 저장된 필드를 제거한다.

[숫자의 증감]
- 해시에 저장된 필드의 값이 숫자 일때, <hincrby>, <hincrbyfloat>으로 처리할 수 있다.
- 감소는 따로 없다. 값을 음수로 넣어줘야함.
- 


[해시 데이터의 키 목록 조회]
- <hgetall> 해시 데이터에 저장된 모든 키의 목록, 모든 값의 목록을 조회 
- <hkeys> : 키에 있는 필드의 목록.
- <hvals> : 필드값의 목록 
-> O(n)을 사용하므로, 데이터가 많을 경우 주의해야 한다.



4.2.3 set 데이터 
- 중복 허용x
- 정렬x
- 집합 연산은 비싼 편에 속한다.
- 데이터 저장 시에 시간 복잡도 = O(N) : 저장하는 요소의 수.

<sinter>
- 주어진 키에 저장된 요소들의 교집합.


[집합 요소조회]
<scard> : 해당 키에 저장되어 있는 요소들의 개수 반환
<srem> : 지정된 요소를 제거. 제거된 요소의 개수를 반환.
<spop>






4.2.4 정렬된 set 데이터

- 요소에 가중치값이 추가되어 있다. 
- 가중치에 따라서 각요소의 정렬이 수행된다.
- default ascending
ex) 실시간 순위 

<zadd>
ex) zadd "key" "가중치" "item"
- 


<zrank> vs <zrevrank>
ex) zrank "key" "item이름"
 -> 해당 item의 오름차순 rank를 제공한다.
 -> 가중치가 가장 큰 것이 가장 큰 rank숫자를 가지게 된다. 
 
<zrange> vs <zrevrange>
ex) zrange "key" "start range" "end range"
: 해당 범위 내에서 순위에 따른 item들을 보여준다.






<zscore>
ex) zscore "key" "item이름"
: 주어진 키의 item의 가중치를 조회한다.







4.2.5 리스트 데이터 

- 저장 순서를 기억.
- 중복을 허용 
- 이중 연결 리스트 구조.
- Dequeue를 구현하고 있다.
- 양쪽 방향에서 모두 입출력을 할 수 있다. 

- 스택, 큐를 모두 나타낼 수 있다. 

[스택]
- 한쪽 방향에서 입력과 삭제가 일어나야함.

[큐]
-


<blpop>, <brpop><prpoplpush>
- 특정 조건이 될 때 까지 blocking한다.
- 

 
4.3 레디스 키 설계 
1) rdb 스키마를 기본으로 하여 레디스의 저장 구조로 바꾸는 방법 
2) 화면에 출력될 데이터를 기준으로 하여 키를 설계하는 방법 

** 키 설계 
- 키 : 조회조건 
- 값 : 화면에 출력 되는 내용 


- NoSQL 데이터 설계 순서 
 * 업무 도메인 분석 
 * 조회할 데이터 
 * 개체 정의
 
 

- RDB에서 관계를 통해서 조회할 최종 데이터를 찾고(by id), 거기에서 필요한 부가 정보들을 읽는다면, 
- nosql에서는 "key"에 해당 최종 데이터를 정의하고, field로 부가정보들을 넣는다. (해시 데이터를 사용하여)
- 즉, RDB의 각 키들을 조합하여 , 레디스의 "key"로 사용한다.
ex) 작성글:사용자번호:작성글번호를 key로 사용한다. 
- 






Chapter.5 레디스 클라이언트 


- 레디스에 데이터를 저장하고 조회하는 방법은 크게 3가지.
1) 레디스 명령행 클라이언트 
2) 레디스 프로토콜을 사용하여 작성된 클라이언트 라이브러리를 사용하는 방법.
3) webdis* , mod_redis*와 같은 플러그인을 사용하는 방법.




5.2 레디스 프로토콜 
- 레디스 서버가 수신하는 모든 명령은 레디스 프로토콜을 통해서 송수신된다.
- TCP/IP사용 
- 서버 환경파일에 기술된 포트를 사용.


5.2.1 프로토콜 구조 
- 바이너리 세이프하다.
- 






***** 레디스 서버가 동작중에 특정 시점의 레디스 데이터를 디스크에 저장한다.
- 이를 스냅샷 파일이라고 부름.
- 이후 레디스 서버가 재시작하면 마지막 스냅샷 시점의 데이터가 로드된다.
- 레디스 서버는 기본적으로 tcp/ip기반으로 데이터를 처리한다.
- 클라의 첫번째 요청에 대한 처리가 완료되기 전에 다음 요청을 처리하지 못한다.

-











chapter6. 레디스 내부구조 

6.1 레디스 객체 

- 레디스는 저장된 데이터를 관리하기 위하여 redisObject 객체를 사용한다.
- 문자열 데이터와 해시 데이터는 모두 redisObject를 사용하여 저장한다.
- redisObject 정보 : 
 * 저장된 객체의 데이터형 (string, list, set, zset, hash)
 * 인코딩 정보 
 * 객체가 참조되고 있는 횟수 
 * LRU 시간정보 
 


 
6.1.1 레디스 인코딩 

- 주 저장소로 메모리를 사용한다.
- 인코딩 종류: 8가지 
 * redis_encoding_raw
 * redis_encoding_int
 * redis_encoding_ht
 * redis_encoding_zipmap
 * redis_encoding_linkedlist
 * redis_encoding_ziplist
 * redis_encoding)intset
 * redis_encoding_skiplist


 
[문자열 데이터 인코딩]
- 입력된 데이터에 대하여 가능한 적은 메모리를 사용하는 인코딩을 선택한다.
- '공유객체'를 사용하여 메모리 낭비를 막는다.
- 10000보다 작은 동일한 숫자를 여러개 등록할 경우, 한 개의 데이터만 들어가고 
나머지는 다 참조로 사용된다. 


[리스트 데이터 인코딩]
- 리스트 데이터형을 저장하기 위한 인코딩 방법. 2가지가 있다. 


- ziplist or linkedlist

- ziplist가 데이터 저장 시 더 적은 메모리를 사용할 수 있다. 그리고 더 많은 cpu를 사용한다.
- linkedlist는 일반적인 리스트와 동일하다.
- list는 초기 생성될 때 모두 'ziplist'로 인코딩된다.
- 이후에 특정 조건에 따라 linkedlist로 변경된다.
 * 입력하려는 값이 list_max_ziplist_value보다 큰 경우 
 * 현재 list의 요소 개수가 list_max_ziplist_enties보다 큰 경우 
 
 
 
 
- 이 두 값을 설정할 수 있는데, 이거를 크게 잡으면 
 -> 나중에 그 큰 한계점에 도달했을 때, linkedlist로 재 인코딩 하기 위하여 
 새로운 리스트 객체를 만들고, 데이터를 복사하여 저장한다. 이를 많은 데이터에 대해서 수행하기 때문에 
 그만큼 더 부하가 크다.
 -> 그 값은 테스트를 통하여 정해야 한다.
 
 - 반대 인코딩은 불가능하다.
 
 
 [set 데이터 인코딩]
 - set 데이터는 O(1)을 제공하기 위하여 내부적으로 해시 테이블 구조로 되어있다.
 - redis_encoding_intset / redis_encoding_HT 인코딩이 있다.
 - 
 
 
6.2 레디스 문자열 
- 문자열을 메모리에 저장할 때 char*를 사용한다.
- 문자열 길이를 확인을 위해서 매번 길이를 세면, 버벅 거리므로 
- sdshdr이라는 구조체를 사용한다.
- 


6.3 레디스 공유객체 
- 자주 사용되는 값을 전역 변수인 공유 객체에 저장해두고 상수처럼 사용한다. 
- 공유객체에는 에러메시지, 프로토콜을 위한 문자열, 자주 사용되는 문자열, 0-9999까지의 숫자가 해당된다.
- 이 모든 값들은 redisObject 구조체를 사용하여 표현된다.
- 공유객체는 redis server가 실행되면 공유객체가 생성된다.
- 





















